<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>微博发布案例最基础版</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .weibo {
      width: 600px;
      border: 1px solid #ccc;

      margin: 100px auto;
      padding: 10px;

    }

    .weibo-text {
      width: 590px;
      height: 140px;
      padding: 5px;
      border: 1px solid #ccc;
      outline: none;
      resize: none;
    }

    .weibo-text:focus {
      border-color: #f60;
    }

    .weibo-btn {
      width: 80px;
      height: 30px;
      background-color: #f90;
      color: #fff;
      border: 0 none;
      margin-top: 5px;
      border-radius: 3px;
      cursor: pointer;
      outline: 0 none;
    }

    .weibo-list {
      padding-top: 10px;
    }

    .weibo-list li {
      font-size: 14px;
      line-height: 30px;
      border-bottom: 1px dotted #ccc;
      overflow: hidden;
    }

    .weibo-list li p {
      float: left;
    }

    .weibo-list li span {
      float: right;
      cursor: pointer;
    }

    .weibo-list li input {
      height: 24px;
      line-height: 24px;
      width: 300px;
      font-size: 14px;
      border: 0 none;
    }
  </style>
</head>

<body>
  <div class="weibo">
    <textarea class="weibo-text"></textarea>
    <input class="weibo-btn" value="发布" type="button">
    <ul class="weibo-list">
      <!-- <li>
        <p class="content">快来收了这九款用上就停不下来的应用吧！！</p>
        <span class="time"></span>
        <span class="del">删除</span>
      </li> -->
    </ul>
  </div>
</body>
<script src="./kits.js">

</script>
<script>
  /*
    微博发布案例思路：
      发布功能
      1.获取元素
      2.点击发布按钮获取文本框中的内容
      3.判断内容是否为空，如果是空就不再往下执行
      4.文本内容不为空，生成一个新的li标签
      5.再生成一个和下面列表结构一致的li标签覆盖新生成的li
      6.将获取到的文本放到新的li中，并加上时间
      7.将新的内容总是放在第一个
      8.发布后清除文本框的内容

      删除功能
      1.获取li标签中的span标签
      2.因为span标签是每次点击才生成的新标签，所以我们可以利用事件委托
      3.给ul注册点击事件
      4.获取点击的span标签
      5.判断如果点击的是span标签
      6.是span就委托ul删除掉它的子元素第一个li

      ctrl+enter发布功能


      本地存储
        要实现每次刷新之后发布的内容都还在，就要把这些内容存进浏览器中，利用本地存储可以实现
  */

  // 发布功能
  //  获取元素
  let text = document.querySelector('.weibo-text');
  let btn = document.querySelector('.weibo-btn');
  let ul = document.querySelector('.weibo-list');

  // 从本地存储中获得数据
  let datas = localStorage.getItem('weibo-datas');
  // 将json类型的数据转成数组类型
  datas = JSON.parse(datas);
  // console.log(datas);
  // 判断数组中一开始是否有数据，如果有偶数据就把这些数据重新赋值，如果没有，datas就是一个空数组
  datas = datas || [];
  console.log(datas);
  // 遍历datas，把数组中的数据添加到页面上
  datas.forEach(function (e, i) {
    // 生成一个新的li标签，现在不能把原来的结构覆盖
    let newLi = document.createElement('li');
    // 生成一个标签结构，覆盖新生成的li
    let time = kits.formatDate();
    newLi.innerHTML = '<p class="content">' + e.content + '</p>' +
      '<span class="del" data-id="' + e.id + '">&nbsp;&nbsp;&nbsp;&nbsp;删除</span>' +
      '<span class="time">' + e.time + '</span>';
    // 将li标签追加的页面中
    ul.appendChild(newLi);
  });


  // 声明一个数组用来存数据
  // let datas = [];



  // 给发布按钮注册点击事件
  btn.onclick = function () {
    // 获取文本框内容，表单元素可以直接用属性value来获取文本
    let content = text.value;
    // 判断文本内容是否为空
    if (content.trim() === '') {
      alert('内容不能空，请重新输入');
      return;
    }
    // 生成一个新的li标签，现在不能把原来的结构覆盖
    let newLi = document.createElement('li');
    // 生成一个标签结构，覆盖新生成的li
    let time = kits.formatDate();
    let id = kits.getID();
    newLi.innerHTML = '<p class="content">' + content + '</p>' +
      '<span class="del" data-id="' + id + '">&nbsp;&nbsp;&nbsp;&nbsp;删除</span>' + '<span class="time">' + time +
      '</span>';
    // 将新生成的标签插入第一个
    ul.insertBefore(newLi, ul.children[0]);

    // 本地存储
    // 将我们发布的内容和时间存储在浏览器中，这样就可以在刷新或者重新打开的时候保存我们发布过的内容，并且删除的内容不会再重新显示
    /*
      实现本地存储思路
        1.声明一个数组存放所有数据
            因为数据由多条，所以我们需要一个数组来存储这些数据
        2.声明一个对象存储文本内容和发布时间
            每条数据都包含两个内容 - 文本内容和发布时间
            用对象来存储每条数据 {content:'内容',time:'发布时间'};
        3.将存储着文本和发布时间的对象放入数组中
        4.将数组转成json格式
        5.将json格式的数组放入本地存储
          
    */
    // 声明对象存放文本内容和发布时间
    let obj = {
      id: id,
      content: content,
      time: time
    };
    // console.log(obj);
    // 将存放内容和时间的对象放入数组中，每次新增的都从前面加入
    datas.unshift(obj);
    // console.log(datas);
    // 将数组转换成json格式后放入本地存储
    localStorage.setItem('weibo-datas', JSON.stringify(datas));
    // 发现这样每次把新增的内容放到本地存储我们只能存到最新发布的数据，最好的办法是在一开始的时候，如果本地存储中有数据，先取出这些数据，然后和新增的数据一起列出来
    // 回到一开始


    // 清除文本内容
    text.value = '';
  }

  // 删除功能
  // 获取span标签
  // let delBtn = document.querySelector('.weibo-list span');
  // // 给删除按钮注册点击事件
  // ul.addEventListener('click', function (event) {
  //   // 判断点击的是否是span标签
  //   if (event.target.nodeName === 'SPAN') {
  //     // 委托ul删除li标签
  //     ul.removeChild(event.target.parentNode);
  //   }
  // });
  // 这样的删除方法不能删除本地存储的数据，刷新之后删除的数据还是一样会显示出来
  // 删除本地数据
  /*
    当我们点击删除的时候，就把该条内容删除，并且本地数据中的也要一起删除
    那么怎么样可以判断出点击的删除是哪条内容的删除？  根据id查找
      给每个本地存储的数据都加一个id，当点击某个删除的时候获取到这个删除对应的id，再根据id从本地存储中把这条数据删除
      
  */
  // 获取元素
  let delBtn = document.querySelector('.weibo-list span');
  // 注册事件
  // 因为li标签是动态生成的，可能一开始没有，所以我们可以使用事件委托，让一开始就存在的元素删除
  // delBtn.onclick=function(){}
  ul.addEventListener('click', function (event) {
    // 判断点击的是不是span
    if (event.target.classList.contains('del')) {
      // 委托ul删除span的父节点li
      ul.removeChild(event.target.parentNode);
      // 到这里只是删除了页面上的li标签，并没有删除掉本地存储中的数据，刷新之后删除的数据还是在
      // 根据id删除本地数据
      // 给标签加上自定义属性来存取id
      // 获取点击的span的id
      let id = event.target.dataset.id;
      console.log(id);

    }
  });
</script>

</html>